## 화살표 함수(arrow function)와 일반 함수(function)의 차이점
************************************************************************************************************************

화살표 함수(arrow function)와 일반 함수(function)의 주요 차이점은 다음과 같습니다

1.문법적인 차이: 화살표 함수는 '=>' 화살표 기호를 사용하여 정의되며, 일반 함수는 'function' 키워드를 사용합니다. 
                화살표 함수는 더 간결한 문법을 가지고 있습니다.

2.this의 바인딩: 화살표 함수는 자체적인 'this'를 가지지 않습니다. 
                대신, 화살표 함수는 자신을 감싸는 범위(lexical scope)의 'this'를 상속받습니다. 
                반면에 일반 함수는 실행 시점에 'this'가 동적으로 바인딩됩니다.

3.arguments 객체: 화살표 함수는 arguments 객체를 가지지 않습니다. 
                  arguments 객체는 일반 함수 내에서 사용되어 함수에 전달된 인자들에 접근할 수 있는 유사 배열 객체입니다.

4.생성자로 사용할 수 없음: 화살표 함수는 생성자 함수로 사용할 수 없습니다. 
                          생성자 함수는 객체 인스턴스를 생성하기 위해 'new' 키워드와 함께 사용되며, 
                          프로토타입과 'this' 바인딩 등의 특별한 동작을 가지고 있습니다.

5.메서드로서의 제한: 화살표 함수는 메서드로 사용될 때 일부 제약이 있습니다. 
                    메서드 내에서 'this'를 사용할 때는 일반 함수를 사용하는 것이 더 적합합니다.

따라서, 일반 함수와 화살표 함수는 다른 문맥에서 사용되며, 각각의 장단점을 고려하여 적절한 상황에서 사용해야 합니다.

************************************************************************************************************************


## useState
************************************************************************************************************************

React의 useState는 함수형 컴포넌트에서 상태(state)를 관리하기 위해 사용되는 훅(hook)입니다. 
useState를 사용하면 컴포넌트의 상태를 선언하고, 상태를 갱신할 수 있습니다.

useState는 배열을 반환하며, 첫 번째 요소는 현재의 상태값이고, 두 번째 요소는 상태를 갱신할 수 있는 함수입니다. 
일반적으로 배열 비구조화 할당을 사용하여 값을 추출합니다.

사용 예시 )

import React, { useState } from 'react';

function Example() {
  // useState를 사용하여 count라는 상태와 setCount라는 상태 갱신 함수를 선언합니다.
  const [count, setCount] = useState(0);

  // 버튼 클릭 시 count 값을 1 증가시키는 함수
  const increment = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

위의 예시에서 useState(0)은 초기 상태값 0을 가지는 count 상태와 count 값을 갱신할 수 있는 setCount 함수를 반환합니다. 
이후에는 setCount 함수를 사용하여 count 값을 갱신할 수 있습니다.

React는 상태의 변경을 감지하고, 변경된 상태를 화면에 자동으로 렌더링합니다. 
따라서 위의 예시에서 버튼을 클릭할 때마다 count 값이 증가하고, 변경된 값이 화면에 업데이트됩니다.

useState를 여러 번 사용하여 여러 개의 상태를 선언할 수도 있습니다. 
각각의 상태는 독립적으로 관리되며, 각각의 상태를 갱신하는 함수를 사용할 수 있습니다.

************************************************************************************************************************


## useEffect
************************************************************************************************************************

React의 useEffect는 함수형 컴포넌트에서 부수 효과(side effect)를 처리하기 위해 사용되는 훅(hook)입니다. 
부수 효과는 컴포넌트 외부와의 상호작용을 의미하며, 주로 데이터 가져오기, 구독 설정, 이벤트 처리 등의 작업을 포함합니다. 
useEffect를 사용하면 컴포넌트의 생명주기와 관련된 작업을 수행할 수 있습니다.

useEffect는 두 개의 인자를 받습니다. 첫 번째 인자는 부수 효과를 수행할 함수이고, 두 번째 인자는 의존성 배열(dependency array)입니다. 
의존성 배열은 useEffect를 언제 호출할지를 결정하는 역할을 합니다.

사용 예시 )

import React, { useEffect } from 'react';

function Example() {
  useEffect(() => {
    // 컴포넌트가 렌더링될 때 실행되는 부수 효과 함수
    console.log('Component rendered');

    // 부수 효과 함수에서 반환한 클린업 함수
    return () => {
      console.log('Component unmounted');
    };
  }, []); // 의존성 배열이 비어있으므로 컴포넌트가 처음 마운트될 때만 실행됨

  return (
    <div>
      <p>Component</p>
    </div>
  );
}

위의 예시에서 useEffect는 컴포넌트가 렌더링될 때마다 실행됩니다. 
이 함수 내부에서는 특정한 동작을 수행할 수 있습니다. 
예를 들어, 외부 API로부터 데이터를 가져와서 상태를 갱신하는 등의 작업을 수행할 수 있습니다.

useEffect는 두 번째 매개변수를 받을 수 있습니다. 
이 매개변수를 사용하면, 특정한 조건에서만 useEffect가 실행되도록 설정할 수 있습니다. 
예를 들어, 특정한 상태 값이 변경될 때만 useEffect가 실행되도록 설정할 수 있습니다.

useEffect는 컴포넌트가 언마운트(unmount)될 때에도 실행됩니다. 
이 때, useEffect 내부에서 clean-up 함수를 반환하여 리소스를 정리할 수 있습니다.

************************************************************************************************************************